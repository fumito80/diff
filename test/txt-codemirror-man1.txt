User manual and reference guide version 5.40.3
CodeMirror is a code-editor component that can be embedded in Web pages. The core library provides only the editor component, no accompanying buttons, auto-completion, or other IDE functionality. It does provide a rich API on top of which such functionality can be straightforwardly implemented. See the addons included in the distribution, and the list of externally hosted addons, for reusable implementations of extra features.

CodeMirror works with language-specific modes. Modes are JavaScript programs that help color (and optionally indent) text written in a given language. The distribution comes with a number of modes (see the mode/ directory), and it isn't hard to write new ones for other languages.

Basic Usage
The easiest way to use CodeMirror is to simply load the script and style sheet found under lib/ in the distribution, plus a mode script from one of the mode/ directories. For example:

<script src="lib/codemirror.js"></script>
<link rel="stylesheet" href="lib/codemirror.css">
<script src="mode/javascript/javascript.js"></script>
(Alternatively, use a module loader. More about that later.)

Having done this, an editor instance can be created like this:

var myCodeMirror = CodeMirror(document.body);
The editor will be appended to the document body, will start empty, and will use the mode that we loaded. To have more control over the new editor, a configuration object can be passed to CodeMirror as a second argument:

var myCodeMirror = CodeMirror(document.body, {
  value: "function myScript(){return 100;}\n",
  mode:  "javascript"
});
This will initialize the editor with a piece of code already in it, and explicitly tell it to use the JavaScript mode (which is useful when multiple modes are loaded). See below for a full discussion of the configuration options that CodeMirror accepts.

In cases where you don't want to append thiiiiitor to an element, and need more control over the way it is inserted, the first argument to the CodeMirror function can also be a function that, when given a DOM element, inserts it into the document somewhere. This could be used to, for example, replace a textarea with a real editor:

var myCodeMirror = CodeMirror(function(elt) {
  myTextArea.parentNode.replaceChild(elt, myTextArea);
}, {value: myTextArea.value});
However, for this use case, which is a common way to use CodeMirror, the library provides a much more powerful shortcut:

var myCodeMirror = CodeMirror.fromTextArea(myTextArea);
This will, among other things, ensure that the textarea's value is updated with the editor's contents when the form (if it is part of a form) is submitted. See the API reference for a full description of this method.
i
The files in the CodeMirror distribution contain shims for loading them (and their depeniiiiiiiiiis) in AMD or CommonJS environments. If the variables exports and module exist and have type object, CommonJS-style require will be used. If not, but there is a function define with an amd property present, AMD-style (RequireJS) will be used.

It is possible to use Browserify or similar tools to statically build modules using CodeMirror. Alternatively, use RequireJS to dynamically load dependencies at runtime. Both of these approaches have the advantage that they don't use the global namespace and can, thus, do things like load multiple versions of CodeMirror alongside each other.

Here's a simple example of using RequireJS to load CodeMirror:

require([
  "cm/lib/codemirror", "cm/mode/htmlmixed/htmlmixed"
], function(CodeMirror) {
  CodeMirror.fromTextArea(document.getElementById("code"), {
    lineNumbers: true,
    mode: "htmlmixed"
  });
});
It will automatically load the modes that the mixed HTML mode depends on (XML, JavaScript, and CSS). Do not use RequireJS' paths option to configure the path to CodeMirror, since it will break loading submodules through relative paths. Use the packages configuration option instead, as in:

require.config({
  packages: [{
    name: "codemirror",
    location: "../path/to/codemirror",
    main: "lib/codemirror"
  }]
});
Configuration
Both the CodeMirror function and its fromTextArea method take as second (optional) argument an object containing configuration options. Any option not supplied like this will be taken from CodeMirror.defaults, an object containing the default options. You can update this object to change the defaults on your page.

Options are not checked in any way, so settingi bogus option values is bound to lead to odd errors.

These are the supported options:

value: string|CodeMirror.Doci
The starting value of the editor. Can be a string, or a document object.
mode: string|object
The mode to use. When not given, this will default to the first mode that was loaded. It may be a string, which either simply names the mode or is a MIME type associated with the mode. Alternatively, it may be an object containing configuration options for the mode, with a name property that names the mode (for example {name: "javascript", json: true}). The demo pages for each mode contain information about what configuration parameters the mode supports. You can ask CodeMirror which modes and MIME types have been defined by inspecting the CodeMirror.modes and CodeMirror.mimeModes objects. The first maps mode names to their constructors, and the second maps MIME types to mode specs.
lineSeparator: string|null
Explicitly set the line separator for the editor. By default (value null), the document will be split on CRLFs as well as lone CRs and LFs, and a single LF will be used as line separator in all output (such as getValue). When a specific string is given, lines will only be split on that string, and output will, by default, use that same separator.
theme: string
The theme to style the editor with. You must make sure the CSS file defining the corresponding .cm-s-[name] styles is loaded (see the theme directory in the distribution). The default is "default", for which colors are included in codemirror.css. It is possible to use multiple theming classes at once—for example "foo bar" will assign both the cm-s-foo and the cm-s-bar classes to the editor.
indentUnit: integer
How many spaces a block (whatever that means in the edited language) should be indented. The default is 2.
smartIndent: boolean
Whether to use the context-sensitive indentation that the mode provides (or just indent the same as the line before). Defaults to true.
tabSize: integer
The width of a tab character. Defaults to 4.
indentWithTabs: boolean
Whether, when indenting, the first N*tabSize spaces should be replaced by N tabs. Default is false.
electricChars: boolean
Configures whether the editor should re-indent the current line when a character is typed that might change its proper indentation (only works if the mode supports indentation). Default is true.
specialChars: RegExp
A regular expression used to determine which characters should be replaced by a special placeholder. Mostly useful for non-printing special characters. The default is /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/.
specialCharPlaceholder: function(char) → Element
A function that, given a special character identified by the specialChars option, produces a DOM node that is used to represent the character. By default, a red dot (•) is shown, with a title tooltip to indicate the character code.
direction: "ltr" | "rtl"
Flips overall layout and selects base paragraph direction to be left-to-right or right-to-left. Default is "ltr". CodeMirror applies the Unicode Bidirectional Algorithm to each line, but does not autodetect base direction — it's set to the editor direction for all lines. The resulting order is sometimes wrong when base direction doesn't match user intent (for example, leading and trailing punctuation jumps to the wrong side of the line). Therefore, it's helpful for multilingual input to let users toggle this option.
rtlMoveVisually: boolean
Determines whether horizontal cursor movement through right-to-left (Arabic, Hebrew) text is visual (pressing the left arrow moves the cursor left) or logical (pressing the left arrow moves to the next lower index in the string, which is visually right in right-to-left text). The default is false on Windows, and true on other platforms.
keyMap: string
Configures the key map to use. The default is "default", which is the only key map defined in codemirror.js itself. Extra key maps are found in the key map directory. See the section on key maps for more information.
extraKeys: object
Can be used to specify extra key bindings for the editor, alongside the ones defined by keyMap. Should be either null, or a valid key map value.
configureMouse: fn(cm: CodeMirror, repeat: "single" | "double" | "triple", event: Event) → Object
Allows you to configure the i" | fn(CodeMirror, Pos) → {from: Pos, to: Pos}
The unit by which to select. May be one of the built-in units or a function that takes a position and returns a range around that, for a custom unit. The default is to return "word" for double clicks, "line" for triple clicks, "rectangle" for alt-clicks (or, on Chrome OS, meta-shift-clicks), and "single" otherwise.
extend: bool
Whether to extend the existing selection range or start a new one. By default, this is enabled when shift clicking.
addNew: bool
When enabled, this adds a new range to the existing selection, rather than replacing it. The default behavior is to enable this for command-click on Mac OS, and control-click on other platforms.
moveOnDrag: bool
When the mouse even drags content around inside the editor, this controls whether it is copied (false) or moved (true). By default, this is enabled by alt-clicking on Mac OS, and ctrl-clicking elsewhere.
lineWrapping: boolean
Whether CodeMirror should scroll or wrap for long lines. Defaults to false (scroll).
lineNumbers: boolean
Whether to show line numbers to the left of the editor.
firstLineNumber: integer
At which number to start counting lines. Default is 1.
lineNumberFormatter: function(line: integer) → string
A function used to format line numbers. The function is passed the line number, and should return a string that will be shown in the gutter.
gutters: array<string>
Can be used to add extra gutters (beyond or instead of the line number gutter). Should be an array of CSS class names, each of which defines a width (and optionally a background), and which will be used to draw the background of the gutters. May include the CodeMirror-linenumbers class, in order to explicitly set the position of the line number gutter (it will default to be to the right of all other gutters). These class names are the keys passed to setGutterMarker.
fixedGutter: boolean
Determines whether the gutter scrolls along with the content horizontally (false) or whether it stays fixed during horizontal scrolling (true, the default).
scrollbarStyle: string
Chooses a scrollbar implementationie default is "native", showing native scrollbars. The core library also provides the "null" style, which completely hides the scrollbars. Addons can implement additional scrollbar models.
coverGutterNextToScrollbar: boolean
When fixedGutter is on, and there is a horizontal scrollbar, by default the gutter will be visible to the left of this scrollbar. If this option is set to true, it will be covered by an element with class CodeMirror-gutter-filler.
inputStyle: string
Selects the way CodeMirror handles input and focus. The core library defines the "textarea" and "contenteditable" input models. On mobile browsers, the default is "contenteditable". On desktop browsers, the default is "textarea". Support for IME and screen readers is better in the "contenteditable" model. The intention is to make it the default on modern desktop browsers in the future.
readOnly: boolean|string
This disables editing of the editor content by the user. If the special value "nocursor" is given (instead of simply true), focusing of the editor is also disallowed.
showCursorWhenSelecting: boolean
Whether the cursor should bei
When enabled, which is the default, doing copy or cut when there is no selection will copy or cut the whole lines that have cursors on them.
pasteLinesPerSelection: boolean
When pasting something from an external source (not from the editor itself), if the number of lines matches the number of selection, CodeMirror will by default insert one line per selection. You can set this to false to disable that behavior.
selectionsMayTouch: boolean
Determines whether multiple selections are joined as soon as they touch (the default) or only when they overlap (true).
undoDepth: integer
The maximum number of undo levels that the editor stores. Note that this includes selection change events. Defaults to 200.
historyEventDelay: integer
The period of inactivity (in milliseconds) that will cause a new history event to be started when typing or deleting. Defaults to 1250.
tabindex: integer
The tab index to assign to the editor. If not given, no tab index will be assigned.
autofocus: boolean
Can be used to make CodeMirror focus itself on initialization. Defaults to off. When fromTextArea is used, and no explicit value is given for this option, it will be set to true when either the source textarea is focused, or it has an autofocus attribute and no other element is focused.
phrases: ?object
Some addons run user-visible strings (such as labels in the interface) through the phrase method to allow for translation. This option determines the return value of that method. When it is null or an object that doesn't have a property named by the input string, that string is returned. Otherwise, the value of the property corresponding to that string is returned.
Below this a few more specialized, low-level options are listed. These are only useful in very specific situations, you might want to skip them the first time you read this manual.

dragDrop: boolean
Controls whether drag-and-drop is enabled. On by default.
allowDropFileTypes: array<string>
When set (default is null) only files whose type is in the array can be dropped into the editor. The strings should be MIME types, and will be checked against the type of the File object as reported by the browser.
cursorBlinkRate: number
Half-period in milliseconds used for cursor blinking. The default blink rate is 530ms. By setting this to zero, blinking can be disabled. A negative value hides the cursor entirely.
cursorScrollMargin: number
How much extra space to always keep above and below the cursor when approaching the top or bottom of the visible view in a scrollable document. Default is 0.
cursorHeight: number
Determines the height of the cursor. Default is 1, meaning it spans the whole height of the line. For some fonts (and by some tastes) a smaller height (for example 0.85), which causes the cursor to not reach all the way to the bottom of the line, looks better
resetSelectionOnContextMenu: boolean
Controls whether, when the context menu is opened with a click outside of the current selection, the cursor is moved to the point of the click. Defaults to true.
workTime, workDelay: number
Highlighting is done by a pseudo background-thread that will work for workTime milliseconds, and then use timeout to sleep for workDelay milliseconds. The defaults are 200 and 300, you can change these options to make the highlighting more or less aggressive.
pollInterval: number
Indicates how quickly CodeMirror should poll its input textarea for changes (when focused). Most input is captured by events, but some things, like IME input on some browsers, don't generate events that allow CodeMirror to properly detect it. Thus, it polls. Default is 100 milliseconds.
flattenSpans: boolean
By default, CodeMirror will combine adjacent tokens into a single span if they have the same class. This will result in a simpler DOM tree, and thus perform better. With some kinds of styling (such as rounded corners), this will change the way the document looks. You can set this option to false to disable this behavior.
addModeClass: boolean
When enabled (off by default), an extra CSS class will be added to each token, indicating the (inner) mode that produced it, prefixed with "cm-m-". For example, tokens from the XML mode will get the cm-m-xml class.
maxHighlightLength: number
When highlightingii long lines, in order to stay responsive, the editor will give up and simply style the rest of the line as plain text when it reaches a certain position. The default is 10 000. You can set this to Infinity to turn off this behavior.
viewportMargin: integer
Specifies the amount of lines that are rendered above and below the part of the document that's currently scrolled into view. This affects the amount of updates needed when scrolling, and the amount of work that such an update does. You should usually leave it at its default, 10. Can be set to Infinity to make sure the whole document is always rendered, and thus the browser's text search works on it. This will have bad effects on performance of big documents.
Events
Various CodeMirror-related objects emit events, which allow client code to react to various situations. Handlers for such events can be registered with the on and off methods on the objects that the event fires on. To fire your own events, use CodeMirror.signal(target, name, args...), where target is a non-DOM-node object.

An editor instance fires the following events. The instance argument always refers to the editor itself.

"change" (instance: CodeMirror, changeObj: object)
Fires every time the content of the editor is changed. The changeObj is a {from, to, text, removed, origin} object containing information about the changes that occurred as second argument. from and to are the positions (in the pre-change coordinate system) where the change started and ended (for example, it might be {ch:0, line:18} if the position is at the beginning of line #19). text is an array of strings representing the text that replaced the changed range (split by line). removed is the text that used to be between from and to, which is overwritten by this change. This event is fired before the end of an operation, before the DOM updates happen.
"changes" (instance: CodeMirror, changes: array<object>)
Like the "change" event, but batched per operation, passing an array containing all the changes that happened in the operation. This event is fired after the operation finished, and display changes it makes will trigger a new operation.
"beforeChange" (instance: CodeMirror, changeObj: object)
This event is fired before a change is applied, and its handler may choose to modify or cancel the change. The changeObj object has from, to, and text properties, as with the "change" event. It also has a cancel() method, which can be called to cancel the change, and, if the change isn't coming from an undo or redo event, an update(from, to, text) method, which may be used to modify the change. Undo or redo changes can't be modified, because they hold some metainformation for restoring old marked ranges that is only valid for that specific change. All three arguments to update are optional, and can be left off to leave the existing value for that field intact. Note: you may not do anything from a "beforeChange" handler that would cause changes to the document or its visualization. Doing so will, since this handler is called directly from the bowels of the CodeMirror implementation, probably cause the editor to become corrupted.
"cursorActivity" (instance: CodeMirror)
Will be fired when the cursor or selection moves, or any change is made to the editor content.
"keyHandled" (instance: CodeMirror, name: string, event: Event)
Fired after a key is handled through a key map. name is the name of the handled key (for example "Ctrl-X" or "'q'"), and event is the DOM keydown or keypress event.
"inputRead" (instance: CodeMirror, changeObj: object)
Fired whenever neiw input is read from the hidden textarea (typed or pasted by the user).
"electricInput" (instance: CodeMirror, line: integer)
Fired if text input matched the mode's electric patterns, and this caused the line's indentation to change.
"beforeSelectionChange" (instance: CodeMirror, obj: {ranges, origin, update})
This event is fired before the selection is moved. Its handler may inspect the set of selection ranges, present as an array of {anchor, head} objects in the ranges property of the obj argument, and optionally change them by calling the update method on this object, passing an array of ranges in the same format. The object also contains an origin property holding the origin string passed to the selection-changing method, if any. Handlers for this event have the same restriction as "beforeChange" handlers — they should not do anything to directly update the state of the editor.
"viewportChange" (instance: CodeMirror, from: number, to: number)
Fires whenever the view port of the editor changes (due to scrolling, editing, or any other factor). The from and to arguments give the new start and end of the viewport.
"swapDoc" (instance: CodeMirror, oldDoc: Doc)
This is signalled when the editor's document is replaced using the swapDoc method.
"gutterClick" (instance: CodeMirror, line: integer, gutter: string, clickEvent: Event)
Fires when the editor gutter (the line-number area) is clicked. Will pass the editor instance as first argument, the (zero-based) number of the line that was clicked as second argument, the CSS class of the gutter that was clicked as third argument, and the raw mousedown event object as fourth argument.
"gutterContextMenu" (instance: CodeMirror, line: integer, gutter: string, contextMenu: Event: Event)
Fires when the editor gutter (the line-number area) receives a contextmenu event. Will pass the editor instance as first argument, the (zero-based) number of the line that was clicked as second argument, the CSS class of the gutter that was clicked as third argument, and the raw contextmenu mouse event object as fourth argument. You can preventDefault the event, to signal that CodeMirror should do no further handling.
"focus" (instance: CodeMirror, event: Event)
Fires whenever the editor is focused.
"blur" (instance: CodeMirror, event: Event)
Fires whenever the editor is unfocused.
"scroll" (instance: CodeMirror)
Fires when the editor is scrolled.
"refresh" (instance: CodeMirror)
Fires when the editor is refreshed or resized. Mostly useful to invalidate cached values that depend on the editor or character size.
"optionChange" (instance: CodeMirror, option: string)
Dispatched every time an option is changed with setOption.
"scrollCursorIntoView" (instance: CodeMirror, event: Event)
Fires when the editor tries to scroli its cursor into view. Can be hooked into to take care of additional scrollable containers around the editor. When the event object has its preventDefault method called, CodeMirror will not itself try to scroll the window.
"update" (instance: CodeMirror)
Will be fired whenever CodeMirror updates its DOM display.
"renderLine" (instance: CodeMirror, line: LineHandle, element: Element)
Fired whenever a line is (re-)rendered to the DOM. Fired right after the DOM element is built, before it is added to the document. The handler may mess with the style of the resulting element, or add event handlers, but should not try to change the state of the editor.
"mousedown", "dblclick", "touchstart", "contextmenu", "keydown", "keypress", "keyup", "cut", "copy", "paste", "dragstart", "dragenter", "dragover", "dragleave", "drop" (instance: CodeMirror, event: Event)
Fired when CodeMirror is handling a DOM event of this type. You can preventDefault the event, or give it a truthy codemirrorIgnore property, to signal that CodeMirror should do no further handling.
Document objects (instances of CodeMirror.Doc) emit the following events:

"change" (doc: CodeMirror.Doc, changeObj: object)
Fired whenever a change occurs to the document. changeObj has a similar type as the object passed to the editor's "change" event.
"beforeChange" (doc: CodeMirror.Doc, change: object)
See the description of the same event on editor instances.
"cursorActivity" (doc: CodeMirror.Doc)
Fired whenever the cursor or selection in this document changes.
"beforeSelectionChange" (doc: CodeMirror.Doc, selection: {head, anchor})
Equivalent to the event by the same name as fired on editor instances.
Line handles (as returned by, for example, getLineHandle) support these events:

"del" ()
Will be fired when the line object is deleted. A line object is associated with the start of the line. Mostly useful when you need to find out when your gutter markers on a given line are removed.
"change" (line: LineHandle, changeObj: object)
Fires when the line's text content is changed in any way (but the line is not deleted outright). The change object is similar to the one passed to change event on the editor object.
Marked range handles (CodeMirror.TextMarker), as returned by markText and setBookmark, emit the following events:

"beforeCursorEnter" ()
Fired when the cursor enters the marked range. From this event handler, the editor state may be inspected but not modified, with the exception that the range on which the event fires may be cleared.
"clear" (from: {line, ch}, to: {line, ch})
Fired when the range is cleared, either through cursor movement in combination with clearOnEnter or through a call to its clear() method. Will only be fired once per handle. Note that deleting the range through text editing does not fire this event, because an undo action might bring the range back into existence. from and to give the part of the document that the range spanned when it was cleared.
"hide" ()
Fired when the last part of the marker is removed from the document by editing operations.
"unhide" ()
Fired when, after the marker was removed by editing, a undo operation brought the marker back.
Line widgets (CodeMirroriiineWidget), returned by addLineWidget, fire these events:

"redraw" ()
Fired whenever the editor re-adds the widget to the DOM. This will happen once right after the widget is added (if it is scrolled into view), and then again whenever it is scrolled out of view and back in again, or when changes to the editor options or the line the widget is on require the widget to be redrawn.
Key Maps
Key maps are ways to associate keys and mouse buttons with functionality. A key map is an object mapping strings that identify the buttons to functions that implement their functionality.

The CodeMirror distributions comes with Emacs, Vim, and Sublime Text-style keymaps.

Keys are identified either by name or by character. The CodeMirror.keyNames object defines names for common keys and associates them with their key codes. Examples of names defined here are Enter, F5, and Q. These can be prefixed with Shift-, Cmd-, Ctrl-, and Alt- to specify a modifier. So for example, Shift-Ctrl-Space would be a valid key identifier.

Common example: map the Tab key to insert spaces instead of a tab character.

editor.setOption("extraKeys", {
  Tab: function(cm) {
    var spaces = Array(cm.getOption("indentUnit") + 1).join(" ");
    cm.replaceSelection(spaces);
  }
});
Alternatively, a character can be specified directly by surrounding it in single quotes, for example '$' or 'q'. Due to limitations in the way browsers fire key events, these may not be prefixed with modifiers.

To bind mouse buttons, use the names `LeftClick`, `MiddleClick`, and `RightClick`. These can also be prefixed with modifiers, and in addition, the word `Double` or `Triple` can be put before `Click` (as in `LeftDoubleClick`) to bind a double- or triple-click. The function for such a binding is passed the position that was clicked as second argument.

Multi-stroke key bindings can be specified by separating the key names by spaces in the property name, for example Ctrl-X Ctrl-V. When a map contains multi-stoke bindings or keys with modifiers that are not specified in the default order (Shift-Cmd-Ctrl-Alt), you must call CodeMirror.normalizeKeyMap on it before it can be used. This function takes a keymap and modifies it to normalize modifier order and properly recognize multi-stroke bindings. It will return the keymap itself.

The CodeMirror.keyMap object associates key maps with names. User code and key map definitions can assign extra properties to this object. Anywhere where a key map is expected, a string can be given, which will be looked up in this object. It also contains the "default" key map holding the default bindings.

The values of properties in key maps can be either functions of a single argument (the CodeMirror instance), strings, or false. Strings refer to commands, which are described below. If the property is set to false, CodeMirror leaves handling of the key up to the browser. A key handler function may return CodeMirror.Pass to indicate that it has decided not to handle the key, and other handlers (or the default behavior) should be given a turn.

Keys mapped to command names that start with the characters "go" or to functions that have a truthy motion property (which should be used for cursor-movement actions) will be fired even when an extra Shift modifier is present (i.e. "Up": "goLineUp" matches both up and shift-up). This is used to easily implement shift-selection.

Key maps can defer to each other by defining a fallthrough property. This indicates that when a key is not found in the map itself, one or more other maps should be searched. It can hold either a single key map or an array of key maps.

When a key map needs to set something up when it becomes active, or tear something down when deactivated, it can contain attach and/or detach properties, which should hold functions that take the editor instance and the next or previous keymap. Note that this only works for the top-level keymap, not for fallthrough maps or maps added with extraKeys or addKeyMap.

Commandsi
Commands are parameter-less actions that can be performed on an editor. Their main use is for key bindings. Commands are defined by adding properties to the CodeMirror.commands object. A number of common commands are defined by the library itself, most of them used by the default key bindings. The value of a command property must be a function of one argument (an editor instance).

Some of the commands below are referenced in the default key map, but not defined by the core library. These are intended to be defined by user code or addons.

Commands can also be run with the execCommand method.

selectAllCtrl-A (PC), Cmd-A (Mac)
Select the whole content of the editor.
singleSelectionEsc
When multiple selections are present, this deselects all but the primary selection.
killLineCtrl-K (Mac)
Emacs-style line killing. Deletes the part of the line after the cursor. If that consists only of whitespace, the newline at the end of the line is also deleted.
deleteLineCtrl-D (PC), Cmd-D (Mac)
Deletes the whole line under the cursor, including newline at the end.
delLineLeft
Delete the part of the line before the cursor.i
delWrappedLineLeftCmd-Backspace (Mac)
Delete the part of the line from the left side of the visual line the cursor is on to the cursor.i
delWrappedLineRightCmd-Delete (Mac)
Delete the part of the line from the cursor to the right side of the visual line the cursor is on.
undoCtrl-Z (PC), Cmd-Z (Mac)
Undo the last change. Note that, because browsers still don't make it possible for scripts to react to or customize the context menu, selecting undo (or redo) from the context menu in a CodeMirror instance does not work.
redoCtrl-Y (PC), Shift-Cmd-Z (Mac), Cmd-Y (Mac)
Redo the last undone change.
undoSelectionCtrl-U (PC), Cmd-U (Mac)
Undo the last change to the selection, or if there are no selection-only changes at the top of the history, undo the last change.
redoSelectionAlt-U (PC), Shift-Cmd-U (Mac)
Redo the last change to the selection, or the last text change if no selection changes remain.
goDocStartCtrl-Home (PC), Cmd-Up (Mac), Cmd-Home (Mac)
Move the cursor to the start of the document.
goDocEndCtrl-End (PC), Cmd-End (Mac), Cmd-Down (Mac)
Move the cursor to the end of the document.
goLineStartAlt-Left (PC), Ctrl-A (Mac)
Move the cursor to the start of the line.
goLineStartSmartHome
Move to the start of the text on the line, or if we are already there, to the actual start of the line (including whitespace).
goLineEndAlt-Right (PC), Ctrl-E (Mac)
Move the cursor to the end of the line.
goLineRightCmd-Right (Mac)
Move the cursor to the right side of the visual line it is on.
goLineLeftCmd-Left (Mac)
Move the cursor to the left side of the visual line it is on. If this line is wrapped, that may not be the start of the line.
goLineLeftSmart
Move the cursor to the left side of the visual line it is on. If that takes it to the start of the line, behave like goLineStartSmart.
goLineUpUp, Ctrl-P (Mac)
Move the cursor up one line.
goLineDownDown, Ctrl-N (Mac)
Move down one line.
goPageUpPageUp, Shift-Ctrl-V (Mac)
Move the cursor up one screen, and scroll up by the same distance.
goPageDownPageDown, Ctrl-V (Mac)
Move the cursor down one screen, and scroll down by the same distance.
goCharLeftLeft, Ctrl-B (Mac)
Move the cursor one character left, going to the previous line when hitting the start of line.
goCharRightRight, Ctrl-F (Mac)
Move the cursor one character right, going to the next line when hitting the end of line.
goColumnLeft
Move the cursor one character left, but don't cross line boundaries.
goColumnRight
Move the cursor one character right, don't cross line boundaries.
goWordLeftAlt-B (Mac)
Move the cursor to the start of the previous word.
goWordRightAlt-F (Mac)
Move the cursor to the end of the next word.
goGroupLeftCtrl-Left (PC), Alt-Left (Mac)
Move to the left of the group before the cursor. A group is a stretch of word characters, a stretch of punctuation characters, a newline, or a stretch of more than one whitespace character.
goGroupRightCtrl-Right (PC), Alt-Right (Mac)
Move to the right of the group after the cursor (see above).
delCharBeforeShift-Backspace, Ctrl-H (Mac)
Delete the character before the cursor.
delCharAfterDelete, Ctrl-D (Mac)
Delete the character after the cursor.
delWordBeforeAlt-Backspace (Mac)
Delete up to the start of the word before the cursor.
delWordAfterAlt-D (Mac)
Delete up to the end of the word after the cursor.
delGroupBeforeCtrl-Backspace (PC), Alt-Backspace (Mac)
Delete to the left of the group before the cursor.
delGroupAfterCtrl-Delete (PC), Ctrl-Alt-Backspace (Mac), Alt-Delete (Mac)
Delete to the start of the group after the cursor.
indentAutoShift-Tab
Auto-indent the current line or selection.
indentMoreCtrl-] (PC), Cmd-] (Mac)
Indent the current line or selection by one indent unit.
indentLessCtrl-[ (PC), Cmd-[ (Mac)
Dedent the current line or selection by one indent unit.
insertTab
Insert a tab character at the cursor.
insertSoftTab
Insert the amount of spaces that match the width a tab at the cursor position would have.
defaultTabTab
If something is selected, indent it by one indent unit. If nothing is selected, insert a tab character.
transposeCharsCtrl-T (Mac)
Swap the characters before and after the cursor.
newlineAndIndentEnter
Insert a newline and auto-indent the new line.
toggleOverwriteInsert
Flip the overwrite flag.
saveCtrl-S (PC), Cmd-S (Mac)
Not defined by the core library, only referred to in key maps. Intended to provide an easy way for user code to define a save command.
findCtrl-F (PC), Cmd-F (Mac)
findNextCtrl-G (PC), Cmd-G (Mac)
findPrevShift-Ctrl-G (PC), Shift-Cmd-G (Mac)
replaceShift-Ctrl-F (PC), Cmd-Alt-F (Mac)
replaceAllShift-Ctrl-R (PC), Shift-Cmd-Alt-F (Mac)
Not defined by the core library, but defined in the search addon (or custom client addons).
Customized Styling
Up to a certain extent, CodeMirror's look can be changed by modifying style sheet files. The style sheets supplied by modes simply provide the colors for that mode, and can be adapted in a very straightforward way. To style the editor itself, it is possible to alter or override the styles defined in codemirror.css.

Some care must be taken there, since a lot of the rules in this file are necessary to have CodeMirror function properly. Adjusting colors should be safe, of course, and with some care a lot of other things can be changed as well. The CSS classes defined in this file serve the following roles:

CodeMirror
The outer element of the editor. This should be used for the editor width, height, borders and positioning. Can also be used to set styles that should hold for everything inside the editor (such as font and font size), or to set a background. Setting this class' height style to auto will make the editor resize to fit its content (it is recommended to also set the viewportMargin option to Infinity when doing this.
CodeMirror-focused
Whenever the editor is focused, the top element gets this class. This is used to hide the cursor and give the selection a different color when the editor is not focused.
CodeMirror-gutters
This is the backdrop for all gutters. Use it to set the default gutter background color, and optionally add a border on the right of the gutters.
CodeMirror-linenumbersi gutter.
CodeMirror-linenumber
Used to style the actual individual line numbers. These won't be children of the CodeMirror-linenumbers (plural) element, but rather will be absolutely positioned to overlay it. Use this to set alignment and text properties for the line numbers.
CodeMirror-lines
The visible lines. This is where you specify vertical padding for the editor content.
CodeMirror-cursor
The cursor is a block element that is absolutely positioned. You can make it look whichever way you want.
CodeMirror-selected
The selection is represented by span elements with this class.
CodeMirror-matchingbracket, CodeMirror-nonmatchingbracket
These are used to style matched (or unmatched) brackets.
If your page's style sheets do funky things to all div or pre elements (you probably shouldn't do that), you'll have to define rules to cancel these effects out again for elements under the CodeMirror class.

Themes are also simply CSS files, which define colors for various syntactic elements. See the files in the theme directory.

Programming API
A lot of CodeMirror features are only available through its API. Thus, you need to write code (or use addons) if you want to expose them to your users.

Whenever points in the document are represented, the API uses objects with line and ch properties. Both are zero-based. CodeMirror makes sure to 'clip' any positions passed by client code so that they fit inside the document, so you shouldn't worry too much about sanitizing your coordinates. If you give ch a value of null, or don't specify it, it will be replaced with the length of the specified line. Such positions may also have a sticky property holding "before" or "after", whether the position is associated with the character before or after it. This influences, for example, where the cursor is drawn on a line-break or bidi-direction boundary.

Methods prefixed with doc. can, unless otherwise specified, be called both on CodeMirror (editor) instances and CodeMirror.Doc instances. Methods prefixed with cm. are only available on CodeMirror instances.

Constructor
Constructing an editor instance is done with the CodeMirror(place: Element|fn(Element), ?option: object) constructor. If the place argument is a DOM element, the editor will be appended to it. If it is a function, it will be called, and is expected to place the editor into the document. options may be an element mapping option names to values. The options that it doesn't explicitly specify (or all options, if it is not passed) will be taken from CodeMirror.defaults.

Note that the options object passed to the constructor will be mutated when the instance's options are changed, so you shouldn't share such objects between instances.

See CodeMirror.fromTextArea for another way to construct an editor instance.

doc.getValue(?separator: string) → string
Get the current editor content. You can pass it an optional argument to specify the string to be used to separate lines (defaults to "\n").
doc.setValue(content: string)
Set the editor content.
doc.getRange(from: {line, ch}, to: {line, ch}, ?separator: string) → string
Get the text between the given points in the editor, which should be {line, ch} objects. An optional third argument can be given to indicate the line separator string to use (defaults to "\n").
doc.replaceRange(replacement: string, from: {line, ch}, to: {line, ch}, ?origin: string)
Replace the part of the document between from and to with the given string. from and to must be {line, ch} objects. to can be left off to simply insert the string at position from. When origin is given, it will be passed on to "change" events, and its first letter will be used to determine whether this change can be merged with previous history events, in the way described for selection origins.
doc.getLine(n: integer) → string
Get the content of line n.
doc.lineCount() → integer
Get the number of lines in the editor.
doc.firstLine() → integer
Get the first line of the editor. This will usually be zero but for linked sub-views, or documents instantiated with a non-zero first line, it might return other values.
doc.lastLine() → integer
Get the last line of the editor. This will usually be doc.lineCount() - 1, but for linked sub-views, it might return other values.
doc.getLineHandle(num: integer) → LineHandle
Fetches the line handle for the given line number.
doc.getLineNumber(handle: LineHandle) → integer
Given a line handle, returns the current position of that line (or null when it is no longer in the document).
doc.eachLine(f: (line: LineHandle))
doc.eachLine(start: integer, end: integer, f: (line: LineHandle))
Iterate over the whole document, or if start and end line numbers are given, the range from start up to (not including) end, and call f for each line, passing the line handle. This is a faster way to visit a range of line handlers than calling getLineHandle for each of them. Note that line handles have a text property containing the line's content (as a string).
doc.markClean()
Set the editor content as 'clean', a flag that it will retain until it is edited, and which will be set again when such an edit is undone again. Useful to track whether the content needs to be saved. This function is deprecated in favor of changeGeneration, which allows multiple subsystems to track different notions of cleanness without interfering.
doc.changeGeneration(?closeEvekt: boolean) → integer
Returns a number that can later be passed to isClean to test whether any edits were made (and not undone) in the meantime. If closeEvent is true, the current history event will be ‘closed’, meaning it can't be combined with further changes (rapid typing or deleting events are typically combined).
doc.isClean(?generation: integer) → boolean
Returns whether the document is currently clean — not modified since initialization or the last call to markClean if no argument is passed, or since the matching call to changeGeneration if a generation value is given.
Cursor and selection methods
doc.getSelection(?lineSep: string) → string
Get the currently selected code. Optionally pass a line separator to put between the lines in the output. When multiple selections are present, they are concatenated with instances of lineSep in between.
doc.getSelections(?lineSep: string) → array<string>
Returns an array containing a string for each selection, representing the content of the selections.
doc.replaceSelection(replacement: string, ?select: string)
Replace the selection(s) with the given string. By default, the new selection ends up after the inserted text. The optional select argument can be used to change this—passing "around" will cause the new text to be selected, passing "start" will collapse the selection to the start of the inserted text.
doc.replaceSelections(replacements: array<string>, ?select: string)
The length of the given array should be the same as the number of active selections. Replaces the content of the selections with the strings in the array. The select argument works the same as in replaceSelection.
doc.getCursor(?start: string) → {line, ch}
Retrieve one end of the primary selection. start is an optional string indicating which end of the selection to return. It may be "from", "to", "head" (the side of the selection that moves when you press shift+arrow), or "anchor" (the fixed side of the selection). Omitting the argument is the same as passing "head". A {line, ch} object will be returned.
doc.listSelections() → array<{anchor, head}>
Retrieves a list of all current selections. These will always be sorted, and never overlap (overlapping selections are merged). Each object in the array contains anchor and head properties referring to {line, ch} objects.
doc.somethingSelected() → boolean
Return true if any text is selected.
doc.setCursor(pos: {line, ch}|number, ?ch: number, ?options: object)l
Set the cursor position. You can either pass a single {line, ch} object, or the line and the character as two separate parameters. Will replace all selections with a single, empty selection at the given position. The supported options are the same as for setSelection.
doc.setSelection(anchor: {line, ch}, ?head: {llline, ch} objects. head defaults to anchor when not given. These options are supported:
scroll: boolean
Determines whether the selection head should be scrolled into view. Defaults to true.
origin: string
Determines whether the selection history event may be merged with the previous one. When an origin starts with the character +, and the last recorded selection had the same origin and was similar (close in time, both collapsed or both non-collapsed), the new one will replace the old one. When it starts with *, it will always replace the previous event (if that had the same origin). Built-in motion uses the "+move" origin. User input uses the "+input" origin.
bias: number
Determine the direction into which the selection endpoints should be adjusted when they fall inside an atomic range. Can be either -1 (backward) or 1 (forward). When not given, the bias will be based on the relative position of the old selection—the editor will try to move further away from that, to prevent getting stuck.
doc.setSelections(ranges: array<{anchor, head}>, ?primary: integer, ?options: object)
Sets a new set of selections. There must be at least one selection in the given array. When primary is a number, it determines which selection is the primary one. When it is not given, the primary index is taken from the previous selection, or set to the last range if the previous selection had less ranges than the new one. Supports the same options as setSelection.
doc.addSelection(anchor: {line, ch}, ?head: {line, ch})
Adds a new selection to the existing set of selections, and makes it the primary selection.
doc.extendSelection(from: {line, ch}, ?to: {line, ch}, ?options: object)
Similar to setSelection, but will, if shift is held or the extending flag is set, move the head of the selection while leaving the anchor at its current place. to is optional, and can be passed to ensure a region (for example a word or paragraph) will end up selected (in addition to whatever lies between that region and the current anchor). When multiple selections are present, all but the primary selection will be dropped by this method. Supports the same options as setSelection.
doc.extendSelections(heads: array<{line, ch}>, ?options: object)
An equivalent of extendSelection that acts on all selections at once.
doc.extendSelectionsBy(f: function(range: {anchor, head}) → {line, ch}), ?options: object)
Applies the given function to all existing selections, and calls extendSelections on the result.
doc.setExtending(value: boolean)
Sets or clears the 'extending' flag, which acts similar to the shift key, in that it will cause cursor movement and calls to extendSelection to leave the selection anchor in place.
doc.getExtending() → boolean
Get the value of the 'extending' flag.
cm.hasFocus() → boolean
Tells you whether the editor currently has focus.
cm.findPosH(start: {line, ch}, amount: integer, unit: string, visually: boolean) → {line, ch, ?hitSide: boolean}
Used to find the target position for horizontal cursor motion. start is a {line, ch} object, amount an integer (may be negative), and unit one of the string "char", "column", or "word". Will return a position that is produced by moving amount times the distance specified by unit. When visually is true, motion in right-to-left text will be visual rather than logical. When the motion was clipped by hitting the end or start of the document, the returned value will have a hitSide property set to true.
cm.findPosV(start: {line, ch}, amount: integer, unit: string) → {line, ch, ?hitSide: boolean}
Similar to findPosH, but used for vertical motion. unit may be "line" or "page". The other arguments and the returned value have the same interpretation as they have in findPosH.
cm.findWordAt(pos: {line, ch}) → {anchor: {line, ch}, head: {line, ch}}
Returns the start and end of the 'word' (the stretch of letters, whitespace, or punctuation) at the given position.
Configuration methods
cm.setOption(option: string, value: any)
Change the configuration of the editor. option should the name of an option, and value should be a valid value for that option.
cm.getOption(option: string) → any
Retrieves the current value of the given option for this editor instance.
cm.addKeyMap(map: object, bottom: boolean)
Attach an additional key map to the editor. This is mostly useful for addons that need to register some key handlers without trampling on the extraKeys option. Maps added in this way have a higher precedence than the extraKeys and keyMap options, and between them, the maps added earlier have a lower precedence than those added later, unless the bottom argument was passed, in which case they end up below other key maps added with this method.
cm.removeKeyMap(map: object)
Disable a keymap added with addKeyMap. Either pass in the key map object itself, or a string, which will be compared against the name property of the active key maps.
cm.addOverlay(mode: string|object, ?options: object)
Enable a highlighting overlay. This is a stateless mini-mode that can be used to add extra highlighting. For example, the search addon uses it to highlight the term that's currently being searched. mode can be a mode spec or a mode object (an object with a token method). The options parameter is optional. If given, it should be an object, optionally containing the following options:
opaque: bool
Defaults to off, but can be given to allow the overlay styling, when not null, to override the styling of the base mode entirely, instead of the two being applied together.
priority: number
Determines the ordering in which the overlays are applied. Those with high priority are applied after those with lower priority, and able to override the opaqueness of the ones that come before. Defaults to 0.
cm.removeOverlay(mode: string|object)
Pass this the exact value passed for the mode parameter to l
Register an event handler for the given event type (a string) on the editor instance. There is also a CodeMirror.on(object, type, func) version that allows registering of events on any object.
cm.off(type: string, func: (...args))
Remove an event handler on the editor instance. An equivalent CodeMirror.off(object, type, func) also exists.
Document management methods
Each editor is associated with an instance of CodeMirror.Doc, its document. A document represents the editor content, plus a selection, an undo history, and a mode. A document can only be associated with a single editor at a time. You can create new documents by calling the CodeMirror.Doc(text: string, mode: Object, firstLineNumber: ?number, lineSeparator: ?string) constructor. The last three arguments are optional and can be used to set a mode for the document, make it start at a line number other than 0, and set a specific line separator respectively.

cm.getDoc() → Doc
Retrieve the currently active document from an editor.
doc.getEditor() → CodeMirror
Retrieve the editor associated with a document. May return null.
cm.swapDoc(doc: CodeMirror.Doc) → Doc
Attach a new document to the editor. Returns the old document, which is now no longer associated with an editor.
doc.copy(copyHistory: boolean) → Doc
Create an identical copy of the given doc. When copyHistory is true, the history will also be copied. Can not be called directly on an editor.
doc.linkedDoc(options: object) → Doc
Create a new document that's linked to the target document. Linked documents will stay in sync (changes to one are also applied to the other) until unlinked. These are the options that are supported:
sharedHist: boolean
When turned on, the linked copy will share an undo history with the original. Thus, something done in one of the two can be undone in the other, and vice versa.
from: integer
to: integer
Can be given to make the new document a subview of the original. Subviews only show a given range of lines. Note that line coordinates inside the subview will be consistent with those of the parent, so that for example a subview starting at line 10 will refer to its first line as line 10, not 0.
mode: string|object
By default, the new document inherits the mode of the parent. This option can be set to a mode spec to give it a different mode.
doc.unlinkDoc(doc: CodeMirror.Doc)
Break the link between two documents. After calling this, changes will no longer propagate between the documents, and, if they had a shared history, the history will become separate.
doc.iterLinkedDocs(function: (doc: CodeMirror.Doc, sharedHist: boolean))
Will call the given function for all documents linked to the target document. It will be passed two arguments, the linked document and a boolean indicating whether that document shares history with the target.
History-related methods
doc.undo()
Undo one edit (if any undo events are stored).
doc.redo()
Redo one undone edit.
doc.undoSelection()
Undo one edit or selection change.
doc.redoSelection()
Redo one undone edit or selection change.
doc.historySize() → {undo: integer, redo: integer}
Returns an object with {undo, redo} properties, both of which hold integers, indicating the amount of stored undo and redo operations.
doc.clearHistory()
Clears the editor's undo history.
doc.getHistory() → object
Get a (JSON-serializable) representation of the undo history.
doc.setHistory(history: object)
Replace the editor's undo history with the one provided, which must be a value as returned by getHistory. Note that this will have entirely undefined results if the editor content isn't also the same as it was when getHistory was called.
Text-marking methods
doc.markText(from: {line, ch}, to: {line, ch}, ?options: object) → TextMarker
Can be used to mark a range of text with a specific Clclass name. from and to should be {line, ch} objects. The options parameter is optional. When given, it should be an object that may contain the following configuration options:
className: string
Assigns a CSS class to the marked stretch of text.
inclusiveLeft: boolean
Determines whether text inserted on the left of the marker will end up inside or outside of it.
inclusiveRight: boolean
Like inclusiveLeft, but for the right side.
atomic: boolean
Atomic ranges act as a single unit when cursor movement is concerned—i.e. it is impossible to place the cursor inside of them. In atomic ranges, inclusiveLeft and inclusiveRight have a different meaning—they will prevent the cursor from being placed respectively directly before and directly after the range.
collapsed: boolean
Collapsed ranges do not show up in the display. Setting a range to be collapsed will automatically make it atomic.
clearOnEnter: boolean
When enabled, will cause the mark to clear itself whenever the cursor enters its range. This is mostly useful for text-replacement widgets that need to 'snap open' when the user tries to edit them. The "clear" event fired on the range handle can be used to be notified when this happens.
clearWhenEmpty: boolean
Determines whether the mark is automatically cleared when it becomes empty. Default is true.
replacedWith: Element
Use a given node to display this range. Implies both collapsed and atomic. The given DOM node must be an inline element (as opposed to a block element).
handleMouseEvents: boolean
When replacedWith is given, this determines whether the editor will capture mouse and drag events occurring in this widget. Default is false—the events will be left alone for the default browser handler, or specific handlers on the widget, to capture.
readOnly: boolean
A read-only span can, as long as it is not cleared, not be modified except by calling setValue to reset the whole document. Note: adding a read-only span currently clears the undo history of the editor, because existing undo events being partially nullified by read-only spans would corrupt the history (in the current implementation).
addToHistory: boolean
When set to true (default is false), adding this marker will create an event in the undo history that can be individually undone (clearing the marker).
startStyle: string
Can be used to specify an extra CSS class to be applied to the leftmost span that is part of the marker.
endStyle: string
Equivalent to startStyle, but for the rightmost span.
css: string
A string of CSS to be applied to the covered text. For example "color: #fe3".
title: string
When given, will give the nodes created for this span a HTML title attribute with the given value.
shared: boolean
When the target document is linked to other documents, you can set shared to true to make the marker appear in all documents. By default, a marker appears only in its target document.
The method will return an object that represents the marker (with constructor CodeMirror.TextMarker), which exposes three methods: clear(), to remove the mark, find(), which returns a {from, to} object (both holding document positions), indicating the current position of the marked range, or undefined if the marker is no longer in the document, and finally changed(), which you can call if you've done something that might change the size of the marker (for example changing the content of a replacedWith node), and want to cheaply update the display.
doc.setBookmark(pos: {line, ch}, ?options: object) → TextMarker
Inserts a bookmark, a handle that follows the text around it as it is being edited, at the given position. A bookmark has two methods find() and clear(). The first returns the current position of the bookmark, if it is still in the document, and the second explicitly removes the bookmark. The options argument is optional. If given, the following properties are recognized:
widget: Element
Can be used to display a DOM node at the current location of the bookmark (analogous to the replacedWith option to markText).
insertLeft: boolean
By default, text typed when the cursor is on top of the bookmark will end up to the right of the bookmark. Set this option to true to make it go to the left instead.
shared: boolean
See the corresponding option to markText.
handleMouseEvents: boolean
As with markText, this determines whether mouse events on the widget inserted for this bookmark are handled by CodeMirror. The default is false.
doc.findMarks(from: {line, ch}, to: {line, ch}) → array<TextMarker>
Returns an array of all the bookmarks and mald ranges found between the given positions (non-inclusive).
doc.findMarksAt(pos: {line, ch}) → array<TextMarker>
Returns an array of all the bookmarks and marked ranges present at the given position.
doc.getAllMarks() → array<TextMarker>
Returns an array containing all marked ranges in the document.
Widget, gutter, and decoration methods
doc.setGutterMarker(line: integer|LineHandle, gutterID: string, value: Element) → LineHandle
Sets the gutter marker for the given gutter (identified by its CSS class, see the gutters option) to the given value. Value can be either null, to clear the marker, or a DOM element, to set it. The DOM element will be shown in the specified gutter next to the specified line.
doc.clearGutter(gutterID: string)
Remove all gutter markers in the gutter with the given ID.
doc.addLineClass(line: integer|LineHandle, where: string, class: string) → LineHandle
Set a CSS class name for the given line. line can be a number or a line handle. where determines to which element this class should be applied, can can be one of "text" (the text element, which lies in front of the selection), "background" (a background element that will be behind the selection), "gutter" (the line's gutter space), or "wrap" (the wrapper node that wraps all of the line's elements, including gutter elements). class should be the name of the class to apply.
doc.removeLineClass(line: integer|LineHandle, where: string, class: string) → LineHandle
Remove a CSS class from a line. line can be a line handle or number. where should be one of "text", "background", or "wrap" (see addLineClass). class can be left off to remove all classes for the specified node, or be a string to remove only a specific class.
doc.lineInfo(line: integer|LineHandle) → object
Returns the line number, text content, and marker status of the given line, which can be either a number or a line handle. The returned object has the structure {line, handle, text, gutterMarkers, textClass, bgClass, wrapClass, widgets}, where gutterMarkers is an object mapping gutter IDs to marker elements, and widgets is an array of line widgets attached to this line, and the various class properties refer to classes added with addLineClass.
cm.addWidget(pos: {line, ch}, node: Element, scrollIntoView: boolean)
Puts node, which should be an absolutely positioned DOM node, into the editor, positioned right below the given {line, ch} position. When scrollIntoView is true, the editor will ensure that the entire node is visible (if possible). To remove the widget again, simply use DOM methods (move it somewhere else, or call removeChild on its parent).
doc.addLineWidget(line: integer|LineHandle, node: Element, ?options: object) → LineWidget
Adds a line widget, an element shown below a line, spanning the whole of the editor's width, and moving the lines below it downwards. line should be either an integer or a line handle, and node should be a DOM node, which will be displayed below the given line. options, when given, should be an object that configures the behavior of the widget. The following options are supported (all default to false):
coverGutter: boolean
Whether the widget should cover the gutter.
noHScroll: boolean
Whether the widget should stay fixed in the face of horizontal scrolling.
above: boolean
Causes the widget to be placed above instead of below the text of the line.
handleMouseEvents: boolean
Determines whether the editor will capture mouse and drag events occurring in this widget. Default is false—the events will be left alone for the default browser handler, or specific handlers on the widget, to capture.
insertAt: integerl
By default, the widget is added below other widgets for the line. This option can be used to place it at a different position (zero for the top, N to put it after the Nth other widget). Note that this only has effect once, when the widget is created.
Note that the widget node will become a descendant of nodes with CodeMirror-specific CSS classes, and those classes might in some cases affect it. This method returns an object that represents the widget placement. It'll have a line property pointing at the line handle that it is associated with, and the following methods:
clear()
Removes the widget.
changed()
Call this if you made some change to the widget's DOM node that might affect its height. It'll force CodeMirror to update the height of the line that contains the widget.
Sizing, scrolling and positioning methods
cm.setSize(width: number|string, height: number|string)
Programmatically set the size of the editor (overriding the applicable CSS rules). width and height can be either numbers (interpreted as pixels) or CSS units ("100%", for example). You can pass null for either of them to indicate that that dimension should not be changed.
cm.scrollTo(x: number, y: number)
Scroll the editor to a given (pixel) position. Both arguments may be left as null or undefined to have no effect.
cm.getScrollInfo() → {left, top, width, height, clientWidth, clientHeight}
Get an {left, top, width, height, clientWidth, clientHeight} object that represents the current scroll position, the size of the scrollable area, and the size of the visible area (minus scrollbars).
cm.scrollIntoView(what: {line, ch}|{left, top, right, bottom}|{from, to}|null, ?margin: number)
Scrolls the given position into view. what may be null to scroll the cursor into view, a {line, ch} position to scroll a character into view, a {left, top, right, bottom} pixel range (in editor-local coordinates), or a range {from, to} containing either two character positions or two pixel squares. The margin parameter is optional. When given, it indicates the amount of vertical pixels around the given area that should be made visible as well.
cm.cursorCoords(where: boolean|{line, ch}, mode: string) → {left, top, bottom}
Returns an {left, top, bottom} object colining the coordinates of the cursor position. If mode is "local", they will be relative to the top-left corner of the editable document. If it is "page" or not given, they are relative to the top-left corner of the page. If mode is "window", the coordinates are relative to the top-left corner of the currently visible (scrolled) window. where can be a boolean indicating whether you want the start (true) or the end (false) of the selection, or, if a {line, ch} object is given, it specifies the precise position at which you want to measure.
cm.charCoords(pos: {line, ch}, ?mode: string) → {left, right, top, bottom}
Returns the position and dimensions of an arbitrary character. pos should be a {line, ch} object. This differs from cursorCoords in that it'll give the size of the whole character, rather than just the position that the cursor would have when it would sit at that position.
cm.coordsChar(object: {left, top}, ?mode: string) → {line, ch}
Given an {left, top} object (e.g. coordinates of a mouse event) returns the {line, ch} position that corresponds to it. The optional mode parameter determines relative to what the coordinates are interpreted. It may be "window", "page" (the default), or "local".
cm.lineAtHeight(height: number, ?mode: string) → number
Computes the line at the given pixel height. mode can be one of the same strings that coordsChar accepts.
cm.heightAtLine(line: integer|LineHandle, ?mode: string, ?includeWidgets: bool) → number
Computes the height of the top of a line, in the coordinate system specified by mode (see coordsChar), which defaults to "page". When a line below the bottom of the document is specified, the returned value is the bottom of the last line in the document. By default, the position of the actual text is returned. If `includeWidgets` is true and the line has line widgets, the position above the first line widget is returned.
cm.defaultTextHeight() → number
Returns the line height of the default font for the editor.
cm.defaultCharWidth() → number
Returns the pixel width of an 'x' in the default font for the editor. (Note that for non-monospace fonts, this is mostly useless, and even for monospace fonts, non-ascii characters might have a different width).
cm.getViewport() → {from: number, to: number}
Returns a {from, to} object indicating the start (inclusive) and end (exclusive) of the currently rendered part of the document. In big documents, when most content is scrolled out of view, CodeMirror will only render the visible part, and a margin around it. See also the viewportChange event.
cm.refresh()
If your code does something to change the size of thle editor element (window resizes are already listened for), or unhides it, you should probably follow up by calling this method to ensure CodeMirror is still looking as intended. See also the autorefresh addon.